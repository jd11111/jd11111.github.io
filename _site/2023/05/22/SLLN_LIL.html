<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>The Law Of The Iterated Logarithm Expained And Visualised | Jannik&#39;s Blog</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="The Law Of The Iterated Logarithm Expained And Visualised" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="The Law Of The Iterated Logarithm Visualizing The Law Of The Iterated Logarithm In Python Basic Code Optimizing The Code Using Numba Performance Analysis" />
<meta property="og:description" content="The Law Of The Iterated Logarithm Visualizing The Law Of The Iterated Logarithm In Python Basic Code Optimizing The Code Using Numba Performance Analysis" />
<link rel="canonical" href="http://localhost:4000/2023/05/22/SLLN_LIL.html" />
<meta property="og:url" content="http://localhost:4000/2023/05/22/SLLN_LIL.html" />
<meta property="og:site_name" content="Jannik&#39;s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-05-22T11:14:45+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="The Law Of The Iterated Logarithm Expained And Visualised" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-05-22T11:14:45+02:00","datePublished":"2023-05-22T11:14:45+02:00","description":"The Law Of The Iterated Logarithm Visualizing The Law Of The Iterated Logarithm In Python Basic Code Optimizing The Code Using Numba Performance Analysis","headline":"The Law Of The Iterated Logarithm Expained And Visualised","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2023/05/22/SLLN_LIL.html"},"url":"http://localhost:4000/2023/05/22/SLLN_LIL.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Jannik&apos;s Blog" /><!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-CKNVMY5C33"></script>
<script>
  MathJax = {
    tex: {
      packages: ['base'],
      tags: 'ams',
      packages: {'[+]': ['ams','mathtools']},
      inlineMath: [['$','$']], 
      displayMath: [["$$","$$"]],
      processEscapes: true,      // use \$ to produce a literal dollar sign
      processEnvironments: true, // process \begin{xxx}...\end{xxx} outside math mode
      processRefs: true,         // process \ref{...} outside of math mode
      formatError:               // function called when TeX syntax errors occur
          (jax, err) => jax.formatError(err)
    }
  }; 
</script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-CKNVMY5C33');
</script></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Jannik&#39;s Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">The Law Of The Iterated Logarithm Expained And Visualised</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2023-05-22T11:14:45+02:00" itemprop="datePublished">May 22, 2023
      </time></p>
  </header>
  <div class="post-content e-content" itemprop="articleBody">
    <ul>
<li><a href="#the-law-of-the-iterated-logarithm">The Law Of The Iterated Logarithm</a></li>
<li><a href="#visualizing-the-law-of-the-iterated-logarithm-in-python">Visualizing The Law Of The Iterated Logarithm In Python</a>
<ul>
<li><a href="#basic-code">Basic Code</a></li>
<li><a href="#optimizing-the-code-using-numba">Optimizing The Code Using Numba</a></li>
<li><a href="#performance-analysis">Performance Analysis</a></li>
</ul>
</li>
</ul>
<p>In the first part of this post you will learn what the law of the iterated logarithm (in the following LIL) means.
In the second part you will learn how to write a simple Python program to visualize the LIL and then how to optimize the program using Numba.
You can find the Jupyter notebook with the code <a href="https://github.com/jd11111/probability/blob/main/SLLN_LIL.ipynb">here</a> on my Github.</p>
<h2 id="the-law-of-the-iterated-logarithm">The Law Of The Iterated Logarithm</h2>
<p>This section will adress what the LIL says and what it means for pratical purposes.
First some notation:
$X$ will denote a sequence of identically and independantly distributed real valued random variables with finite mean $\mu$ and variance $\sigma^2$.
The $n$-sample mean $\bar{X}_n $ of $X$ is defined by $\bar{X}_n =  n^{-1} \sum_{i=1}^n X_i $.</p>
<p>The SLLN states that $\bar{X}_n $ converges to $\mu$ almost surely (from now on a.s.) as $ n \to \infty$.</p>
<p>But it does not tell us how fast $\bar{X}_n $ converges to $\mu$.
This is where the LIL comes in.
Define a sequence of real numbers $l$ by
$
\begin{equation}
l_n=\sigma \sqrt{2/n \log ( \log ( n))} \quad \text{for} \ n &gt; e
\end{equation}
$
Note that $\lim_{n \to \infty } l_n =0$.
Then the LIL says that
$$
\begin{equation}
\tag{1}
\limsup_{n \to \infty} l_n^{-1} |\bar{X}_n - \mu|= 1 \quad \text{a.s.}
\end{equation}
$$
Unravelling the definition this means that the following is true for $\forall \varepsilon &gt;0$:
$$
\begin{equation}
| \bar{X}_n - \mu| &lt; (1 + \varepsilon )l_n \quad \text{a.s.}
\end{equation}
$$
for all but finitely many $n$ and
$$
\begin{equation}
(1 - \varepsilon ) l_n &lt; | \bar{X}_n - \mu| \quad \text{a.s.}
\end{equation}
$$
for infinitely many $n$.
Using the <a href="https://en.wikipedia.org/wiki/Big_O_notation#Formal_definition">big-$\mathcal{O}$ notation</a> the LIL is therefore equivalent to saying that $|\bar{X}_n - \mu| = \mathcal{O}(l_n)$ a.s. as $n \to \infty$ with any bounding constant $&gt;1$, but not with any bounding constant $&lt;1$.
So the LIL gives us an upper bound for the speed of convergence in the SLLN for large $n$.
Furthermore the LIL also tells us that
$$
\begin{equation}
\lim x_n^{-1} l_n^{-1} |\bar{X}_n - \mu| = 0  \quad \text{a.s.}
\end{equation}
$$
for any sequence of positive real numbers $x$ that converges to $\infty$ (follows from the rules of the product of $\limsup$'s).
In other words using the <a href="https://en.wikipedia.org/wiki/Big_O_notation#Little-o_notation">little-$o$ notation</a> $\bar{X}_n - \mu = o(x_n l_n) $ a.s. as $n \to \infty$.</p>
<p>We can numerically visualize these relations by generating $X_1( \omega), X_2 (\omega) , \dots , X_N (\omega)$ for multiple outcomes ${ \omega_1, \dots, \omega_M } $ and then plotting both $l_n$ and $\bar{X}_n(\omega) -\mu$ for all $n \in {1 , \dots , N}$ and $\omega \in { \omega_1, \dots, \omega_M } $.
The sequence $(\bar{X}_1(\omega) -\mu , \dots ,\bar{X}_N(\omega) -\mu)$ ($\omega$ fixed) is called a path in the following.
This has been done for a standard normal distribution (mean 0, variance 1) with 800 paths to produce the following figure:</p>
<p><img src="/assets/iterlog.png" alt="paths" /></p>
<p>A logarithmic scale is used on the horizontal axis, while a 10-th root scale is used on the vertical axis.
Each colored line is the path for one outcome.
The dash-dotted line visualizes that $|\bar{X}_n - \mu| = \mathcal{O}(l_n)$ a.s. and the solid line that $|\bar{X}_n - \mu| = o(x_n l_n)$ a.s. with $x_n = n^{0.2}$. Also note how slow the sample mean really converges, even after using $10^9$ samples there are still deviations in the order of $10^4$ from the real mean.</p>
<h2 id="visualizing-the-law-of-the-iterated-logarithm-in-python">Visualizing The Law Of The Iterated Logarithm In Python</h2>
<p>This section will tell you how to write a python program to visualise the LIL as discussed in the preceding section and how to optimize it.</p>
<h1 id="basic-code">Basic Code</h1>
<p>We will start with a simple python program.
The libary <code>numpy</code> will be used to do the heavy lifting, while <code>matplotlib</code> will be used for plotting:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span> 
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
</code></pre></div></div>
<p>The following function computes the values of <code>M</code> paths for a standard normal distribution (mean zero and variance 1) and returns their values for the $n$ in <code>ns</code>.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">generate_paths_basic</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">ns</span><span class="p">):</span>
    <span class="s">"""returns an array containing the values of M different paths at the values of n in ns"""</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">Generator</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">SFC64</span><span class="p">())</span> <span class="c1">#nitialize RNG
</span>    <span class="n">rand</span> <span class="o">=</span> <span class="n">rng</span><span class="p">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">ns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span> <span class="c1">#generate normal distributed data
</span>    <span class="n">paths</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">rand</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#calculate the partial sums from n=1 to n=ns[-1]
</span>    <span class="k">return</span> <span class="n">paths</span><span class="p">[:,</span><span class="n">ns</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#only return the partial sums for those values of n in ns
</span></code></pre></div></div>
<p>We dont want to display the paths for all values of $n$. A logarithmic scale is a good idea:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">X</span><span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">logspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="n">base</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">num</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span> <span class="c1">#create array of numbers between 10**1 and 10**6 that are equally  that are evenly spaced on a log scale for plotting of the iterated logarithm
</span><span class="n">ns</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nb">round</span><span class="p">(</span><span class="n">X</span><span class="p">).</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">int64</span><span class="p">))</span> <span class="c1">#create array of integers between 10**1 and 10**6 that are equally spaced on a log scale for plotting of the paths
</span></code></pre></div></div>
<p>Lets generate 80 paths</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">paths</span> <span class="o">=</span> <span class="n">generate_paths_basic</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span><span class="n">ns</span><span class="p">)</span> 
</code></pre></div></div>
<p>and define the sequence $l_n$ to compare the paths with:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">iterlog</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">&lt;=</span><span class="n">np</span><span class="p">.</span><span class="n">e</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="n">x</span><span class="o">*</span><span class="n">np</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>

<span class="n">iterlog</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">iterlog</span><span class="p">)</span> <span class="c1">#to make sure the function is employed element-wise on arrays
</span></code></pre></div></div>
<p>Finally we can visualize the results:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">subplots</span><span class="p">()</span>

<span class="n">ax</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">iterlog</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="n">color</span><span class="o">=</span><span class="s">"black"</span><span class="p">,</span><span class="n">lw</span> <span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s">"$\sqrt{2  /n \log ( \log (n))}$"</span><span class="p">)</span> <span class="c1">#plot the iterated logarithm
</span><span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="nb">abs</span><span class="p">(</span><span class="n">path</span><span class="o">/</span><span class="n">ns</span><span class="p">),</span><span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#plot the path
</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">"Number of samples $n$"</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s">"Deviation from mean $|\bar{X}_n |$"</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s">"log"</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">ns</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">"SLLN and LIL"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>
<p><img src="/assets/SLLN_LIL_files/SLLN_LIL_12_0.png" alt="png" /></p>
<h1 id="optimizing-the-code-using-numba">Optimizing The Code Using Numba</h1>
<p>This section tells you how to optimize the above code to deal with large numbers of samples.
In the process you will learn to write fast python code that leverages parallel computation with numba.
So lets get into it:
While the above code is very simple and executes relatively fast it has a big problem if we want to calculate the paths for even larger $n$:
It uses way too much ram.
This is because the function <code>generate_paths_basic</code> creates two huge arrays to store the random data and the partial sums in.
Of course we dont really need to generate all random data at once and store it in an array.
We also dont need to store all values of the paths.
Instead we only need to store the values of the paths that we want to display and we can generate random numbers as we are using them.
So lets optimize the code with the goal not to waste ram. While we are at it we can also add multi-threading.
To facilitate this we will be using the <code>numba</code> and the <code>threading </code> module.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span> 
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span> 
<span class="kn">import</span> <span class="nn">numba</span> <span class="k">as</span> <span class="n">nb</span> 
<span class="kn">import</span> <span class="nn">threading</span>
</code></pre></div></div>
<p>The following function will be used to calculate the path differences between values of $n$ that we are interested in.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">nb</span><span class="p">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">fastmath</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">nogil</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">partial_sum</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
    <span class="s">"""take an instance rng of the np.random.Generator() class and sum n normally distributed samples drawn from rng"""</span>
    <span class="n">var</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">var</span><span class="o">+=</span><span class="n">rng</span><span class="p">.</span><span class="n">normal</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">var</span>
</code></pre></div></div>
<p>We are using the <code>@nb.jit</code> decorator to tell <code>numba</code> to treat the function to make it fast.
We pass an instance of the <code>np.random.Generator()</code> class to use it within the numba'd function (this only works because there is explicit support for this in numba).
This function has the advantage of not saving intermediate results and not creating large arrays (unlike using numpy would).
The usage of numba is critical, because the same code using vanilla python would run very slow and would be restricted from multi-threading by the python GIL.
We can use the <code>partial_sum</code> function to define a function that calculates the values of the paths at those $n$ in <code>ns</code>:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">nb</span><span class="p">.</span><span class="n">jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">fastmath</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">nogil</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">generate_paths</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span><span class="n">rng</span><span class="p">,</span><span class="n">ns</span><span class="p">,</span><span class="n">diffs</span><span class="p">):</span>
    <span class="s">"""takes an array paths and writes the relevant path values in it for paths.shape[0] different paths. Uses random samples from rng."""</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">paths</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">paths</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">partial_sum</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span><span class="n">ns</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">ind</span><span class="p">,</span><span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">diffs</span><span class="p">):</span>
            <span class="n">paths</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">ind</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">partial_sum</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span><span class="n">val</span><span class="p">)</span><span class="o">+</span><span class="n">paths</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">ind</span><span class="p">]</span>
</code></pre></div></div>
<p>and use it to do multi-threading:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">generate_paths_mt</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">threadnr</span><span class="p">,</span><span class="n">ns</span><span class="p">):</span>
    <span class="s">"""generate M paths (M is expected to be an integer multiple of threadnr) using threadnr different threads returning an array containing the values of the paths for those n in ns"""</span>
    <span class="n">paths</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="p">)))</span> <span class="c1">#array to save the values of the paths
</span>    <span class="n">diffs</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span> <span class="c1">#array of differences in ns i.e. diffs[i] = ns[i+1]-ns[i]
</span>    <span class="n">chunk_len</span> <span class="o">=</span> <span class="n">paths</span><span class="p">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="n">threadnr</span> <span class="c1">#number of paths each thread calculates 
</span>    <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">paths</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">chunk_len</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">chunk_len</span><span class="p">,:]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">threadnr</span><span class="p">)]</span> <span class="c1">#one slice of the paths array for each thread to execute generate_paths on
</span>    <span class="n">rngs</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">Generator</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">random</span><span class="p">.</span><span class="n">SFC64</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">threadnr</span><span class="p">)]</span> <span class="c1"># one rng for each thread
</span>    <span class="n">threads</span> <span class="o">=</span> <span class="p">[</span><span class="n">threading</span><span class="p">.</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">generate_paths</span><span class="p">,</span><span class="n">args</span><span class="o">=</span><span class="p">([</span><span class="n">chunks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">rngs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">ns</span><span class="p">,</span><span class="n">diffs</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">threadnr</span><span class="p">)]</span> <span class="c1">#create the threads
</span>    <span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
        <span class="n">thread</span><span class="p">.</span><span class="n">start</span><span class="p">()</span><span class="c1">#start the thread
</span>    <span class="k">for</span> <span class="n">thread</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
        <span class="n">thread</span><span class="p">.</span><span class="n">join</span><span class="p">()</span><span class="c1">#wait for the thread to finish
</span>    <span class="k">return</span> <span class="n">paths</span>
</code></pre></div></div>
<p>There are two things worthy of notice here: Firstly the RNG that we are using is not thread-safe, therefore every thread must have their own RNG.
Secondly this form of multi-threading only speeds up computation because we call functions that haven been numba'd with the <code>nogil=True</code>option circumventing the Python GIL.</p>
<p>Lets use this function to generate 80 paths with a large number of samples:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">X</span><span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">logspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="n">base</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">num</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span> <span class="c1">#create array of equally spaced numbers on log scale for plotting of the iterated logarithm
</span><span class="n">ns</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nb">round</span><span class="p">(</span><span class="n">X</span><span class="p">).</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">int64</span><span class="p">))</span> <span class="c1">#create array of equally spaced integers on log scale for plotting of the paths
</span></code></pre></div></div>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">paths</span> <span class="o">=</span> <span class="n">generate_paths_mt</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="n">ns</span><span class="p">)</span>
</code></pre></div></div>
<p>To visualise the data we proceed as before (the function <code>iterlog</code> is defined as in the preceding section).
The only changes are to add a 10-th root scale for better visibility of the data and to add some fancy ticks and tick labels.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="p">.</span><span class="n">subplots</span><span class="p">()</span>

<span class="n">ax</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">iterlog</span><span class="p">(</span><span class="n">X</span><span class="p">),</span><span class="n">color</span><span class="o">=</span><span class="s">"black"</span><span class="p">,</span><span class="n">lw</span> <span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">ls</span><span class="o">=</span><span class="s">"--"</span><span class="p">,</span><span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s">"$ \sigma \sqrt{2  /n \log ( \log (n))}$"</span><span class="p">)</span> <span class="c1">#plot the iterated logarithm
</span>
<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
    <span class="n">ax</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span><span class="n">np</span><span class="p">.</span><span class="nb">abs</span><span class="p">(</span><span class="n">p</span><span class="o">/</span><span class="n">ns</span><span class="p">),</span><span class="n">lw</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#plot the path
</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s">"Number of samples $n$"</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="sa">r</span><span class="s">"Deviation from mean $|\bar{X}_n - \mu|$"</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s">"log"</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">ns</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ns</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="mi">10</span>

<span class="n">ax</span><span class="p">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s">"function"</span><span class="p">,</span> <span class="n">functions</span><span class="o">=</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">))</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">10</span><span class="o">**-</span><span class="mi">4</span><span class="p">,</span><span class="mi">10</span><span class="o">**</span><span class="mi">0</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_yticks</span><span class="p">([</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)])</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_yticks</span><span class="p">([(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span> <span class="p">],</span><span class="n">minor</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">.</span><span class="n">set_yticklabels</span><span class="p">([</span><span class="s">"$10^{}$"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="s">"{"</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s">"}"</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)])</span>

<span class="n">plt</span><span class="p">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="n">title</span><span class="p">(</span><span class="s">"SLLN and LIL"</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>
<p><img src="/assets/SLLN_LIL_files/SLLN_LIL_27_0.png" alt="png" /></p>
<h1 id="performance-analysis">Performance Analysis</h1>
<p>It is interesting to compare the performance of the two functions in a like for like scenario:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">threadnr</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">M</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">threadnr</span> <span class="c1">#number of paths to calculate (expected to be integer multiple of the thread number)
</span></code></pre></div></div>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">X</span><span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">logspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="n">base</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">num</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span> <span class="c1">#create array of equally spaced numbers on log scale for plotting of the iterated logarithm
</span><span class="n">ns</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nb">round</span><span class="p">(</span><span class="n">X</span><span class="p">).</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">int64</span><span class="p">))</span> <span class="c1">#create array of equally spaced integers on log scale for plotting of the paths
</span></code></pre></div></div>
<p>First up a single thread vs single thread test:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">timeit</span> <span class="n">paths</span> <span class="o">=</span> <span class="n">generate_paths_mt</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">ns</span><span class="p">)</span> <span class="c1">#using 1 thread to compare
</span></code></pre></div></div>
<pre><code>723 ms ± 19 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
</code></pre>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">timeit</span> <span class="n">paths</span> <span class="o">=</span> <span class="n">generate_paths_basic</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">ns</span><span class="p">)</span>
</code></pre></div></div>
<pre><code>1.67 s ± 54.8 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
</code></pre>
<p>The optimized code is more than two times faster than the basic code!
Now lets use the maximum of 8 threads on my 4C/8T system:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">timeit</span> <span class="n">paths</span> <span class="o">=</span> <span class="n">generate_paths_mt</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="n">ns</span><span class="p">)</span> <span class="c1">#using all 8 available threads (4C/8T)
</span></code></pre></div></div>
<pre><code>191 ms ± 8.81 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
</code></pre>
<p>As expected almost four times faster than with 1 thread!
We can also test with 4 threads (so no hyperthreading is in use):</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%</span><span class="n">timeit</span> <span class="n">paths</span> <span class="o">=</span> <span class="n">generate_paths_mt</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="n">ns</span><span class="p">)</span> <span class="c1">#using 4 available threads (one per core) (4C/8T)
</span></code></pre></div></div>
<pre><code>220 ms ± 3.8 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
</code></pre>
<p>Around 15 percent slower than with hyperthreading.</p>

  </div><a class="u-url" href="/2023/05/22/SLLN_LIL.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Jannik&#39;s Blog</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Jannik&#39;s Blog</li><li><a class="u-email" href="mailto:jannik.daun@proton.me">jannik.daun@proton.me</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jd11111"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jd11111</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Blog about mathematics, physics and code by Jannik Daun</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
